<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ç™½AIå›¾ç‰‡å»æ°´å°</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' style='stop-color:%236366f1'/><stop offset='100%25' style='stop-color:%238b5cf6'/></linearGradient></defs><rect width='100' height='100' rx='20' fill='url(%23g)'/><text x='50' y='68' font-size='50' text-anchor='middle' fill='white'>âœ¨</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1400px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            line-height: 1.2;
        }

        .logo-emoji {
            font-size: 1.2em;
            margin-right: 5px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        /* æ¨¡å¼åˆ‡æ¢ */
        .mode-switch {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 12px 24px;
            border: 2px solid #6366f1;
            border-radius: 25px;
            background: white;
            color: #6366f1;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-btn:hover {
            background: #f0f4ff;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            border-color: transparent;
        }

        .mode-btn .icon {
            font-size: 1.2em;
        }

        .upload-area {
            border: 3px dashed #6366f1;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
            position: relative;
        }

        .upload-area:hover {
            border-color: #4f46e5;
            background: #f0f4ff;
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #4f46e5;
            background: #e0e7ff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 1.2em;
            color: #6366f1;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .upload-hint {
            color: #999;
            font-size: 0.9em;
        }

        #fileInput {
            display: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            min-width: 150px;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(99, 102, 241, 0.4);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        /* ç”»ç¬”å·¥å…·æ  */
        .brush-toolbar {
            display: none;
            background: #f8f9ff;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 20px;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .brush-toolbar.visible {
            display: flex;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toolbar-label {
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
        }

        .brush-size-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .brush-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
        }

        .tool-btn {
            padding: 8px 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            color: #333;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tool-btn:hover {
            border-color: #6366f1;
            background: #f0f4ff;
        }

        .tool-btn.active {
            border-color: #6366f1;
            background: #6366f1;
            color: white;
        }

        .tool-btn.danger {
            border-color: #dc3545;
            color: #dc3545;
        }

        .tool-btn.danger:hover {
            background: #dc3545;
            color: white;
        }

        /* ç¼–è¾‘å™¨å®¹å™¨ */
        .editor-container {
            display: none;
            position: relative;
            margin-bottom: 20px;
        }

        .editor-container.visible {
            display: block;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            max-width: 100%;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
        }

        #imageCanvas {
            display: block;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            cursor: crosshair;
            /* ä¸è®¾ç½® max-width/max-heightï¼Œè®© JS å®Œå…¨æ§åˆ¶å°ºå¯¸ */
        }

        #maskCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            border-radius: 10px;
            /* ä¸è®¾ç½® max-width/max-heightï¼Œè®© JS å®Œå…¨æ§åˆ¶å°ºå¯¸ */
        }

        .editor-hint {
            text-align: center;
            color: #666;
            margin-top: 15px;
            font-size: 0.95em;
        }

        .editor-hint .highlight {
            color: #6366f1;
            font-weight: 600;
        }

        /* æ£€æµ‹ç»“æœæç¤º */
        .detection-result {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #0ea5e9;
            border-radius: 12px;
            padding: 15px 20px;
            margin-top: 15px;
            text-align: center;
        }

        .detection-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: #0369a1;
            font-weight: 500;
        }

        .detection-icon {
            font-size: 1.4em;
        }

        /* æ°´å°åŒºåŸŸæ ‡è®°æ ·å¼ - å¯æ‹–æ‹½è°ƒæ•´ï¼ˆè“ç´«è‰²è°ƒï¼‰ */
        .watermark-overlay {
            position: absolute;
            border: 3px solid #8b5cf6;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 8px;
            cursor: move;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.9), 0 0 20px rgba(139, 92, 246, 0.4);
            min-width: 30px;
            min-height: 30px;
            transition: box-shadow 0.2s ease;
        }

        .watermark-overlay:hover {
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.9), 0 0 30px rgba(139, 92, 246, 0.6);
        }

        .watermark-label {
            position: absolute;
            top: -32px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        /* æ‹–æ‹½æ‰‹æŸ„ */
        .resize-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border: 2px solid white;
            border-radius: 4px;
            z-index: 10;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .resize-handle:hover {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            transform: scale(1.2);
            box-shadow: 0 3px 8px rgba(99, 102, 241, 0.4);
        }

        .resize-handle.top-left {
            top: -7px;
            left: -7px;
            cursor: nwse-resize;
        }

        .resize-handle.top-right {
            top: -7px;
            right: -7px;
            cursor: nesw-resize;
        }

        .resize-handle.bottom-left {
            bottom: -7px;
            left: -7px;
            cursor: nesw-resize;
        }

        .resize-handle.bottom-right {
            bottom: -7px;
            right: -7px;
            cursor: nwse-resize;
        }

        .resize-handle.top {
            top: -7px;
            left: 50%;
            transform: translateX(-50%);
            cursor: ns-resize;
        }

        .resize-handle.bottom {
            bottom: -7px;
            left: 50%;
            transform: translateX(-50%);
            cursor: ns-resize;
        }

        .resize-handle.left {
            left: -7px;
            top: 50%;
            transform: translateY(-50%);
            cursor: ew-resize;
        }

        .resize-handle.right {
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
            cursor: ew-resize;
        }

        /* å°ºå¯¸æ˜¾ç¤º */
        .size-indicator {
            position: absolute;
            bottom: -28px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(99, 102, 241, 0.9);
            color: white;
            padding: 3px 10px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 2px 6px rgba(99, 102, 241, 0.3);
        }

        .preview-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .preview-box {
            text-align: center;
        }

        .preview-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }

        .preview-image {
            max-width: 100%;
            max-height: 500px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
        }

        .download-btn {
            background: #28a745;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: none;
        }

        .download-btn:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #6366f1;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        /* éšè—ç±» */
        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            .preview-container {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 1.8em;
            }

            .mode-switch {
                flex-direction: column;
                align-items: center;
            }

            .brush-toolbar {
                flex-direction: column;
                align-items: stretch;
            }

            .toolbar-group {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1><span class="logo-emoji">âœ¨</span> å°ç™½AIå›¾ç‰‡å»æ°´å°</h1>
        <p class="subtitle">æ”¯æŒè‡ªåŠ¨æ£€æµ‹æˆ–æ‰‹åŠ¨æ ‡è®°æ°´å°åŒºåŸŸ</p>

        <div class="error" id="errorMsg"></div>
        <div class="success" id="successMsg"></div>

        <!-- æ¨¡å¼åˆ‡æ¢ -->
        <div class="mode-switch">
            <button class="mode-btn active" id="autoModeBtn" data-mode="auto">
                <span class="icon">ğŸ¤–</span>
                <span>è‡ªåŠ¨æ¨¡å¼</span>
            </button>
            <button class="mode-btn" id="manualModeBtn" data-mode="manual">
                <span class="icon">ğŸ–Œï¸</span>
                <span>æ‰‹åŠ¨æ“¦é™¤</span>
            </button>
        </div>

        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">ğŸ“¤</div>
            <div class="upload-text">ç‚¹å‡»ä¸Šä¼ æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</div>
            <div class="upload-hint">æ”¯æŒ JPGã€PNG æ ¼å¼ | ä¹Ÿå¯ä»¥ç›´æ¥ç²˜è´´å›¾ç‰‡</div>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <!-- ç”»ç¬”å·¥å…·æ  -->
        <div class="brush-toolbar" id="brushToolbar">
            <div class="toolbar-group">
                <span class="toolbar-label">ç”»ç¬”å¤§å°:</span>
                <input type="range" class="brush-size-slider" id="brushSize" min="5" max="100" value="30">
                <span id="brushSizeValue">30px</span>
            </div>
            <div class="toolbar-group">
                <button class="tool-btn active" id="brushBtn">
                    <span>ğŸ–Œï¸</span>
                    <span>ç”»ç¬”</span>
                </button>
                <button class="tool-btn" id="eraserBtn">
                    <span>ğŸ§¹</span>
                    <span>æ©¡çš®æ“¦</span>
                </button>
            </div>
            <div class="toolbar-group">
                <button class="tool-btn danger" id="clearMaskBtn">
                    <span>ğŸ—‘ï¸</span>
                    <span>æ¸…é™¤æ ‡è®°</span>
                </button>
            </div>
        </div>

        <!-- ç¼–è¾‘å™¨å®¹å™¨ï¼ˆè‡ªåŠ¨æ¨¡å¼å’Œæ‰‹åŠ¨æ¨¡å¼å…±ç”¨ï¼‰ -->
        <div class="editor-container" id="editorContainer">
            <div class="canvas-wrapper" id="canvasWrapper">
                <div class="canvas-container" id="canvasContainer">
                    <canvas id="imageCanvas"></canvas>
                    <canvas id="maskCanvas"></canvas>
                </div>
            </div>
            <p class="editor-hint" id="editorHint">
                <span class="highlight">æç¤ºï¼š</span>ç”¨ç”»ç¬”æ¶‚æŠ¹éœ€è¦å»é™¤çš„æ°´å°åŒºåŸŸï¼Œç„¶åç‚¹å‡»"å¼€å§‹å»æ°´å°"
            </p>
            <!-- è‡ªåŠ¨æ¨¡å¼çš„æ£€æµ‹ç»“æœæç¤º -->
            <div class="detection-result" id="detectionResult" style="display: none;">
                <div class="detection-info">
                    <span class="detection-icon">ğŸ¯</span>
                    <span>å·²æ£€æµ‹åˆ°æ°´å°åŒºåŸŸ | <strong>å¯æ‹–æ‹½è¾¹æ¡†è°ƒæ•´ä½ç½®å’Œå¤§å°</strong> | ç¡®è®¤åç‚¹å‡»"å¼€å§‹å»æ°´å°"</span>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="processBtn" disabled>å¼€å§‹å»æ°´å°</button>
            <button class="btn btn-secondary" id="resetBtn">é‡ç½®</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>æ­£åœ¨ä½¿ç”¨ AI å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...</div>
        </div>

        <div class="preview-container" id="previewContainer" style="display: none;">
            <div class="preview-box">
                <div class="preview-title">åŸå§‹å›¾ç‰‡</div>
                <img id="originalImage" class="preview-image" alt="åŸå§‹å›¾ç‰‡">
            </div>
            <div class="preview-box">
                <div class="preview-title">å¤„ç†åå›¾ç‰‡</div>
                <img id="processedImage" class="preview-image" alt="å¤„ç†åå›¾ç‰‡">
                <button class="download-btn" id="downloadBtn">ä¸‹è½½å›¾ç‰‡</button>
            </div>
        </div>
    </div>

    <script>
        // DOM å…ƒç´ 
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const processBtn = document.getElementById('processBtn');
        const resetBtn = document.getElementById('resetBtn');
        const originalImage = document.getElementById('originalImage');
        const processedImage = document.getElementById('processedImage');
        const downloadBtn = document.getElementById('downloadBtn');
        const loading = document.getElementById('loading');
        const errorMsg = document.getElementById('errorMsg');
        const successMsg = document.getElementById('successMsg');
        const previewContainer = document.getElementById('previewContainer');
        
        // æ¨¡å¼åˆ‡æ¢
        const autoModeBtn = document.getElementById('autoModeBtn');
        const manualModeBtn = document.getElementById('manualModeBtn');
        
        // ç”»ç¬”å·¥å…·
        const brushToolbar = document.getElementById('brushToolbar');
        const editorContainer = document.getElementById('editorContainer');
        const imageCanvas = document.getElementById('imageCanvas');
        const maskCanvas = document.getElementById('maskCanvas');
        const brushSize = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const brushBtn = document.getElementById('brushBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const clearMaskBtn = document.getElementById('clearMaskBtn');
        const canvasWrapper = document.getElementById('canvasWrapper');

        // çŠ¶æ€å˜é‡
        let currentFile = null;
        let processedImageBlob = null;
        let currentMode = 'auto'; // 'auto' æˆ– 'manual'
        let isDrawing = false;
        let currentTool = 'brush'; // 'brush' æˆ– 'eraser'
        let imageObj = null;
        let canvasScale = 1;
        let detectedWatermark = null;  // ä¿å­˜æ£€æµ‹åˆ°çš„æ°´å°åŒºåŸŸ
        let watermarkOverlay = null;   // æ°´å°æ ‡è®° DOM å…ƒç´ 
        let customWatermarkRegion = null;  // ç”¨æˆ·è°ƒæ•´åçš„æ°´å°åŒºåŸŸï¼ˆåŸå§‹åæ ‡ï¼‰
        let currentAbortController = null;  // ç”¨äºä¸­æ­¢è¿›è¡Œä¸­çš„è¯·æ±‚

        // æ‹–æ‹½çŠ¶æ€
        let isDragging = false;
        let isResizing = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let overlayStartX = 0;
        let overlayStartY = 0;
        let overlayStartWidth = 0;
        let overlayStartHeight = 0;
        let currentResizeHandle = null;

        // Canvas ä¸Šä¸‹æ–‡
        let imgCtx = null;
        let maskCtx = null;
        
        // æ–°å¢ DOM å…ƒç´ 
        const editorHint = document.getElementById('editorHint');
        const detectionResult = document.getElementById('detectionResult');
        const canvasContainer = document.getElementById('canvasContainer');

        // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
        function showError(message) {
            errorMsg.textContent = message;
            errorMsg.style.display = 'block';
            successMsg.style.display = 'none';
            setTimeout(() => {
                errorMsg.style.display = 'none';
            }, 5000);
        }

        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        function showSuccess(message) {
            successMsg.textContent = message;
            successMsg.style.display = 'block';
            errorMsg.style.display = 'none';
            setTimeout(() => {
                successMsg.style.display = 'none';
            }, 3000);
        }

        // æ¨¡å¼åˆ‡æ¢
        function switchMode(mode) {
            currentMode = mode;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            autoModeBtn.classList.toggle('active', mode === 'auto');
            manualModeBtn.classList.toggle('active', mode === 'manual');
            
            // æ›´æ–°ç•Œé¢
            if (mode === 'manual') {
                brushToolbar.classList.add('visible');
                removeWatermarkOverlay(); // æ‰‹åŠ¨æ¨¡å¼ä¸æ˜¾ç¤ºè‡ªåŠ¨æ£€æµ‹çš„æ ‡è®°
                if (imageObj) {
                    editorContainer.classList.add('visible');
                    uploadArea.style.display = 'none';
                }
            } else {
                brushToolbar.classList.remove('visible');
                // è‡ªåŠ¨æ¨¡å¼ä¹Ÿæ˜¾ç¤ºç¼–è¾‘å™¨å®¹å™¨æ¥å±•ç¤ºæ£€æµ‹ç»“æœ
                if (imageObj) {
                    editorContainer.classList.add('visible');
                    uploadArea.style.display = 'none';
                    // å¦‚æœå·²æœ‰æ£€æµ‹ç»“æœï¼Œæ˜¾ç¤ºæ ‡è®°
                    if (detectedWatermark) {
                        showWatermarkOverlay(
                            detectedWatermark.watermark_region,
                            detectedWatermark.image_size
                        );
                    }
                } else if (currentFile) {
                    uploadArea.style.display = 'none';
                } else {
                    uploadArea.style.display = 'block';
                }
            }
            
            // æ›´æ–°æç¤ºä¿¡æ¯
            updateEditorHint();
            
            // æ¸…é™¤æ‰‹åŠ¨æ¨¡å¼çš„ mask
            if (mode === 'auto' && maskCtx) {
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            }
        }

        autoModeBtn.addEventListener('click', () => switchMode('auto'));
        manualModeBtn.addEventListener('click', () => switchMode('manual'));

        // ç”»ç¬”å¤§å°æ›´æ–°
        brushSize.addEventListener('input', (e) => {
            brushSizeValue.textContent = e.target.value + 'px';
        });

        // å·¥å…·åˆ‡æ¢
        brushBtn.addEventListener('click', () => {
            currentTool = 'brush';
            brushBtn.classList.add('active');
            eraserBtn.classList.remove('active');
        });

        eraserBtn.addEventListener('click', () => {
            currentTool = 'eraser';
            eraserBtn.classList.add('active');
            brushBtn.classList.remove('active');
        });

        // æ¸…é™¤æ ‡è®°
        clearMaskBtn.addEventListener('click', () => {
            if (maskCtx) {
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            }
        });

        // ä¸­æ­¢å½“å‰è¿›è¡Œä¸­çš„è¯·æ±‚
        function abortCurrentRequest() {
            if (currentAbortController) {
                currentAbortController.abort();
                currentAbortController = null;
                console.log('[Abort] Current request aborted');
            }
        }

        // æ£€æµ‹æ°´å°åŒºåŸŸ
        async function detectWatermark(file) {
            // ä¸­æ­¢ä¹‹å‰çš„è¯·æ±‚
            abortCurrentRequest();
            
            // åˆ›å»ºæ–°çš„ AbortController
            currentAbortController = new AbortController();
            
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch('/api/detect-watermark', {
                    method: 'POST',
                    body: formData,
                    signal: currentAbortController.signal
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'æ£€æµ‹å¤±è´¥');
                }
                
                const result = await response.json();
                console.log('[Detect] Watermark detected:', result);
                currentAbortController = null;
                return result;
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('[Detect] Request was aborted');
                    return null;
                }
                console.error('[Detect] Error:', error);
                showError('æ°´å°æ£€æµ‹å¤±è´¥ï¼š' + error.message);
                currentAbortController = null;
                return null;
            }
        }

        // æ˜¾ç¤ºæ°´å°åŒºåŸŸæ ‡è®°ï¼ˆå¯æ‹–æ‹½è°ƒæ•´ï¼‰
        function showWatermarkOverlay(watermarkRegion, imageSize) {
            // ç§»é™¤æ—§çš„æ ‡è®°
            removeWatermarkOverlay();
            
            if (!watermarkRegion || !imageObj) return;
            
            // è®¡ç®—ç¼©æ”¾åçš„åæ ‡
            const displayWidth = imageCanvas.width;
            const displayHeight = imageCanvas.height;
            const scaleX = displayWidth / imageSize.width;
            const scaleY = displayHeight / imageSize.height;
            
            const x = watermarkRegion.x1 * scaleX;
            const y = watermarkRegion.y1 * scaleY;
            const width = watermarkRegion.width * scaleX;
            const height = watermarkRegion.height * scaleY;
            
            // åˆ›å»ºæ°´å°æ ‡è®°å…ƒç´ 
            watermarkOverlay = document.createElement('div');
            watermarkOverlay.className = 'watermark-overlay';
            watermarkOverlay.style.left = x + 'px';
            watermarkOverlay.style.top = y + 'px';
            watermarkOverlay.style.width = width + 'px';
            watermarkOverlay.style.height = height + 'px';
            
            // æ·»åŠ æ ‡ç­¾
            const label = document.createElement('div');
            label.className = 'watermark-label';
            label.textContent = 'æ‹–æ‹½è°ƒæ•´åŒºåŸŸ';
            watermarkOverlay.appendChild(label);
            
            // æ·»åŠ å°ºå¯¸æŒ‡ç¤ºå™¨
            const sizeIndicator = document.createElement('div');
            sizeIndicator.className = 'size-indicator';
            sizeIndicator.id = 'sizeIndicator';
            updateSizeIndicator(sizeIndicator, watermarkRegion.width, watermarkRegion.height);
            watermarkOverlay.appendChild(sizeIndicator);
            
            // æ·»åŠ 8ä¸ªæ‹–æ‹½æ‰‹æŸ„
            const handles = ['top-left', 'top', 'top-right', 'left', 'right', 'bottom-left', 'bottom', 'bottom-right'];
            handles.forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${pos}`;
                handle.dataset.handle = pos;
                watermarkOverlay.appendChild(handle);
            });
            
            canvasContainer.appendChild(watermarkOverlay);
            
            // åˆå§‹åŒ–è‡ªå®šä¹‰åŒºåŸŸï¼ˆåŸå§‹åæ ‡ï¼‰
            customWatermarkRegion = {
                x1: watermarkRegion.x1,
                y1: watermarkRegion.y1,
                x2: watermarkRegion.x1 + watermarkRegion.width,
                y2: watermarkRegion.y1 + watermarkRegion.height,
                width: watermarkRegion.width,
                height: watermarkRegion.height
            };
            
            // ç»‘å®šæ‹–æ‹½äº‹ä»¶
            bindOverlayEvents();
            
            console.log(`[Overlay] Displayed at (${x.toFixed(1)}, ${y.toFixed(1)}), size: ${width.toFixed(1)}x${height.toFixed(1)}`);
        }

        // æ›´æ–°å°ºå¯¸æ˜¾ç¤º
        function updateSizeIndicator(element, width, height) {
            element.textContent = `${Math.round(width)} Ã— ${Math.round(height)} px`;
        }

        // ç»‘å®šæ‹–æ‹½äº‹ä»¶
        function bindOverlayEvents() {
            if (!watermarkOverlay) return;
            
            // ç§»åŠ¨æ•´ä¸ªåŒºåŸŸ
            watermarkOverlay.addEventListener('mousedown', onOverlayMouseDown);
            
            // æ‹–æ‹½æ‰‹æŸ„äº‹ä»¶
            const handles = watermarkOverlay.querySelectorAll('.resize-handle');
            handles.forEach(handle => {
                handle.addEventListener('mousedown', onHandleMouseDown);
            });
            
            // å…¨å±€äº‹ä»¶
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // ç‚¹å‡»æ°´å°åŒºåŸŸå¼€å§‹æ‹–æ‹½
        function onOverlayMouseDown(e) {
            if (e.target.classList.contains('resize-handle')) return;
            e.preventDefault();
            e.stopPropagation();
            
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            overlayStartX = parseFloat(watermarkOverlay.style.left);
            overlayStartY = parseFloat(watermarkOverlay.style.top);
        }

        // ç‚¹å‡»æ‰‹æŸ„å¼€å§‹è°ƒæ•´å¤§å°
        function onHandleMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            
            isResizing = true;
            currentResizeHandle = e.target.dataset.handle;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            overlayStartX = parseFloat(watermarkOverlay.style.left);
            overlayStartY = parseFloat(watermarkOverlay.style.top);
            overlayStartWidth = parseFloat(watermarkOverlay.style.width);
            overlayStartHeight = parseFloat(watermarkOverlay.style.height);
        }

        // é¼ æ ‡ç§»åŠ¨
        function onMouseMove(e) {
            if (!isDragging && !isResizing) return;
            
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;
            
            if (isDragging) {
                // ç§»åŠ¨åŒºåŸŸ
                let newX = overlayStartX + dx;
                let newY = overlayStartY + dy;
                
                // è¾¹ç•Œé™åˆ¶
                const maxX = imageCanvas.width - parseFloat(watermarkOverlay.style.width);
                const maxY = imageCanvas.height - parseFloat(watermarkOverlay.style.height);
                newX = Math.max(0, Math.min(newX, maxX));
                newY = Math.max(0, Math.min(newY, maxY));
                
                watermarkOverlay.style.left = newX + 'px';
                watermarkOverlay.style.top = newY + 'px';
            } else if (isResizing) {
                // è°ƒæ•´å¤§å°
                let newX = overlayStartX;
                let newY = overlayStartY;
                let newWidth = overlayStartWidth;
                let newHeight = overlayStartHeight;
                
                const minSize = 30;
                
                // æ ¹æ®æ‰‹æŸ„ä½ç½®è°ƒæ•´
                if (currentResizeHandle.includes('left')) {
                    newWidth = overlayStartWidth - dx;
                    if (newWidth >= minSize) {
                        newX = overlayStartX + dx;
                    } else {
                        newWidth = minSize;
                    }
                }
                if (currentResizeHandle.includes('right')) {
                    newWidth = overlayStartWidth + dx;
                    if (newWidth < minSize) newWidth = minSize;
                }
                if (currentResizeHandle.includes('top')) {
                    newHeight = overlayStartHeight - dy;
                    if (newHeight >= minSize) {
                        newY = overlayStartY + dy;
                    } else {
                        newHeight = minSize;
                    }
                }
                if (currentResizeHandle.includes('bottom')) {
                    newHeight = overlayStartHeight + dy;
                    if (newHeight < minSize) newHeight = minSize;
                }
                
                // è¾¹ç•Œé™åˆ¶
                if (newX < 0) { newWidth += newX; newX = 0; }
                if (newY < 0) { newHeight += newY; newY = 0; }
                if (newX + newWidth > imageCanvas.width) newWidth = imageCanvas.width - newX;
                if (newY + newHeight > imageCanvas.height) newHeight = imageCanvas.height - newY;
                
                watermarkOverlay.style.left = newX + 'px';
                watermarkOverlay.style.top = newY + 'px';
                watermarkOverlay.style.width = newWidth + 'px';
                watermarkOverlay.style.height = newHeight + 'px';
                
                // æ›´æ–°å°ºå¯¸æ˜¾ç¤ºï¼ˆè½¬æ¢ä¸ºåŸå§‹å°ºå¯¸ï¼‰
                const scaleX = imageObj.width / imageCanvas.width;
                const scaleY = imageObj.height / imageCanvas.height;
                const sizeIndicator = document.getElementById('sizeIndicator');
                if (sizeIndicator) {
                    updateSizeIndicator(sizeIndicator, newWidth * scaleX, newHeight * scaleY);
                }
            }
        }

        // é¼ æ ‡é‡Šæ”¾
        function onMouseUp(e) {
            if (isDragging || isResizing) {
                // æ›´æ–°è‡ªå®šä¹‰åŒºåŸŸåæ ‡ï¼ˆè½¬æ¢ä¸ºåŸå§‹å°ºå¯¸ï¼‰
                updateCustomWatermarkRegion();
            }
            isDragging = false;
            isResizing = false;
            currentResizeHandle = null;
        }

        // æ›´æ–°è‡ªå®šä¹‰æ°´å°åŒºåŸŸï¼ˆåŸå§‹åæ ‡ï¼‰
        function updateCustomWatermarkRegion() {
            if (!watermarkOverlay || !imageObj) return;
            
            const scaleX = imageObj.width / imageCanvas.width;
            const scaleY = imageObj.height / imageCanvas.height;
            
            const x = parseFloat(watermarkOverlay.style.left) * scaleX;
            const y = parseFloat(watermarkOverlay.style.top) * scaleY;
            const width = parseFloat(watermarkOverlay.style.width) * scaleX;
            const height = parseFloat(watermarkOverlay.style.height) * scaleY;
            
            customWatermarkRegion = {
                x1: Math.round(x),
                y1: Math.round(y),
                x2: Math.round(x + width),
                y2: Math.round(y + height),
                width: Math.round(width),
                height: Math.round(height)
            };
            
            console.log('[Custom Region] Updated:', customWatermarkRegion);
        }

        // ç§»é™¤æ°´å°åŒºåŸŸæ ‡è®°
        function removeWatermarkOverlay() {
            if (watermarkOverlay) {
                watermarkOverlay.remove();
                watermarkOverlay = null;
            }
            customWatermarkRegion = null;
            isDragging = false;
            isResizing = false;
        }

        // æ›´æ–°æç¤ºä¿¡æ¯
        function updateEditorHint() {
            if (currentMode === 'manual') {
                editorHint.innerHTML = '<span class="highlight">æç¤ºï¼š</span>ç”¨ç”»ç¬”æ¶‚æŠ¹éœ€è¦å»é™¤çš„æ°´å°åŒºåŸŸï¼Œç„¶åç‚¹å‡»"å¼€å§‹å»æ°´å°"';
                editorHint.style.display = 'block';
                detectionResult.style.display = 'none';
            } else {
                editorHint.style.display = 'none';
                if (detectedWatermark) {
                    detectionResult.style.display = 'block';
                } else {
                    detectionResult.style.display = 'none';
                }
            }
        }

        // åˆå§‹åŒ–ç”»å¸ƒ
        function initCanvas(img) {
            imageObj = img;
            
            // è®¡ç®—ç”»å¸ƒå°ºå¯¸ï¼ˆé™åˆ¶æœ€å¤§å°ºå¯¸ï¼‰
            const containerWidth = canvasWrapper.clientWidth || window.innerWidth - 100;
            const maxWidth = Math.min(containerWidth - 40, 900);
            const maxHeight = 550;
            
            let displayWidth = img.width;
            let displayHeight = img.height;
            
            // æŒ‰æ¯”ä¾‹ç¼©æ”¾
            if (displayWidth > maxWidth) {
                displayHeight = displayHeight * (maxWidth / displayWidth);
                displayWidth = maxWidth;
            }
            if (displayHeight > maxHeight) {
                displayWidth = displayWidth * (maxHeight / displayHeight);
                displayHeight = maxHeight;
            }
            
            // å–æ•´ï¼Œé¿å…æ¨¡ç³Š
            displayWidth = Math.round(displayWidth);
            displayHeight = Math.round(displayHeight);
            
            canvasScale = img.width / displayWidth;
            
            // è®¾ç½®ç”»å¸ƒçš„å†…éƒ¨å°ºå¯¸ï¼ˆç»˜å›¾å°ºå¯¸ï¼‰
            imageCanvas.width = displayWidth;
            imageCanvas.height = displayHeight;
            maskCanvas.width = displayWidth;
            maskCanvas.height = displayHeight;
            
            // è®¾ç½®æ ·å¼å°ºå¯¸ï¼ˆæ˜¾ç¤ºå°ºå¯¸ï¼‰- ä¸å†…éƒ¨å°ºå¯¸ä¿æŒä¸€è‡´
            imageCanvas.style.width = displayWidth + 'px';
            imageCanvas.style.height = displayHeight + 'px';
            maskCanvas.style.width = displayWidth + 'px';
            maskCanvas.style.height = displayHeight + 'px';
            
            // ç»˜åˆ¶å›¾ç‰‡
            imgCtx = imageCanvas.getContext('2d');
            imgCtx.clearRect(0, 0, displayWidth, displayHeight);
            imgCtx.drawImage(img, 0, 0, displayWidth, displayHeight);
            
            // åˆå§‹åŒ– mask ç”»å¸ƒ
            maskCtx = maskCanvas.getContext('2d');
            maskCtx.clearRect(0, 0, displayWidth, displayHeight);
            
            console.log(`Canvas initialized: ${displayWidth}x${displayHeight}, scale: ${canvasScale}`);
        }

        // è·å–ç”»å¸ƒåæ ‡
        function getCanvasCoords(e) {
            const rect = imageCanvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            // è®¡ç®—é¼ æ ‡åœ¨ Canvas å†…çš„ç›¸å¯¹ä½ç½®
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            // è€ƒè™‘ Canvas çš„æ˜¾ç¤ºå°ºå¯¸å’Œå†…éƒ¨å°ºå¯¸çš„æ¯”ä¾‹
            // å¦‚æœ CSS æ”¹å˜äº† Canvas çš„æ˜¾ç¤ºå¤§å°ï¼Œéœ€è¦è¿›è¡Œç¼©æ”¾è½¬æ¢
            const scaleX = imageCanvas.width / rect.width;
            const scaleY = imageCanvas.height / rect.height;
            
            return {
                x: x * scaleX,
                y: y * scaleY
            };
        }

        // ç»˜åˆ¶
        function draw(e) {
            if (!isDrawing || !maskCtx) return;
            e.preventDefault();
            
            const coords = getCanvasCoords(e);
            const size = parseInt(brushSize.value);
            
            // ç¡®ä¿åæ ‡åœ¨æœ‰æ•ˆèŒƒå›´å†…
            if (coords.x < 0 || coords.y < 0 || 
                coords.x > maskCanvas.width || coords.y > maskCanvas.height) {
                return;
            }
            
            maskCtx.beginPath();
            maskCtx.arc(coords.x, coords.y, size / 2, 0, Math.PI * 2);
            
            if (currentTool === 'brush') {
                maskCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                maskCtx.fill();
            } else {
                maskCtx.globalCompositeOperation = 'destination-out';
                maskCtx.fill();
                maskCtx.globalCompositeOperation = 'source-over';
            }
        }

        // ç”»å¸ƒäº‹ä»¶
        imageCanvas.addEventListener('mousedown', (e) => {
            if (currentMode !== 'manual') return;
            e.preventDefault();
            isDrawing = true;
            draw(e);
        });

        imageCanvas.addEventListener('mousemove', (e) => {
            if (currentMode !== 'manual') return;
            draw(e);
        });
        
        imageCanvas.addEventListener('mouseup', (e) => {
            isDrawing = false;
        });

        imageCanvas.addEventListener('mouseleave', (e) => {
            isDrawing = false;
        });

        // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
        imageCanvas.addEventListener('touchstart', (e) => {
            if (currentMode !== 'manual') return;
            e.preventDefault();
            isDrawing = true;
            draw(e);
        });

        imageCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e);
        });

        imageCanvas.addEventListener('touchend', () => {
            isDrawing = false;
        });

        // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸ
        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        // æ–‡ä»¶é€‰æ‹©
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // æ‹–æ‹½ä¸Šä¼ 
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        // ç²˜è´´ä¸Šä¼ 
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    handleFile(blob);
                    showSuccess('å·²ä»å‰ªè´´æ¿ç²˜è´´å›¾ç‰‡');
                    break;
                }
            }
        });

        // å¤„ç†æ–‡ä»¶
        async function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showError('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }

            currentFile = file;
            detectedWatermark = null;  // é‡ç½®æ£€æµ‹ç»“æœ
            removeWatermarkOverlay();
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                // è®¾ç½®é¢„è§ˆå›¾
                originalImage.src = e.target.result;
                
                // åŠ è½½å›¾ç‰‡åˆ°ç”»å¸ƒ
                const img = new Image();
                img.onload = async () => {
                    initCanvas(img);
                    
                    // æ˜¾ç¤ºç¼–è¾‘å™¨å®¹å™¨
                    editorContainer.classList.add('visible');
                    uploadArea.style.display = 'none';
                    
                    // æ ¹æ®æ¨¡å¼æ˜¾ç¤ºç•Œé¢
                    if (currentMode === 'manual') {
                        brushToolbar.classList.add('visible');
                    } else {
                        // è‡ªåŠ¨æ¨¡å¼ï¼šæ£€æµ‹æ°´å°
                        loading.style.display = 'block';
                        loading.querySelector('div:last-child').textContent = 'æ­£åœ¨æ£€æµ‹æ°´å°ä½ç½®...';
                        
                        try {
                            const result = await detectWatermark(file);
                            if (result && result.success) {
                                detectedWatermark = result;
                                showWatermarkOverlay(result.watermark_region, result.image_size);
                                showSuccess('å·²æ£€æµ‹åˆ°æ°´å°åŒºåŸŸï¼Œè¯·ç¡®è®¤åç‚¹å‡»"å¼€å§‹å»æ°´å°"');
                            }
                        } catch (error) {
                            console.error('Detection error:', error);
                        }
                        
                        loading.style.display = 'none';
                        loading.querySelector('div:last-child').textContent = 'æ­£åœ¨ä½¿ç”¨ AI å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...';
                    }
                    
                    // æ›´æ–°æç¤ºä¿¡æ¯
                    updateEditorHint();
                    
                    processedImage.src = '';
                    downloadBtn.style.display = 'none';
                    processBtn.disabled = false;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // è·å– mask æ•°æ®
        function getMaskDataURL() {
            if (!maskCtx || currentMode !== 'manual') {
                return null;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ç»˜åˆ¶å†…å®¹ï¼ˆæ£€æŸ¥ maskCanvas çš„ alpha é€šé“ï¼‰
            const maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
            let hasContent = false;
            for (let i = 3; i < maskImageData.data.length; i += 4) {
                if (maskImageData.data[i] > 0) {
                    hasContent = true;
                    break;
                }
            }
            
            if (!hasContent) {
                console.log('[Mask] No content drawn');
                return null;
            }
            
            // åˆ›å»ºçº¯é»‘ç™½ maskï¼ˆç™½è‰²è¡¨ç¤ºéœ€è¦å»é™¤çš„åŒºåŸŸï¼‰
            // ä½¿ç”¨åŸå§‹å›¾ç‰‡å°ºå¯¸
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imageObj.width;
            tempCanvas.height = imageObj.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // å¡«å……é»‘è‰²èƒŒæ™¯
            tempCtx.fillStyle = 'black';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // å°† maskCanvas ç¼©æ”¾ç»˜åˆ¶åˆ° tempCanvas
            // å…ˆè®¾ç½®æ··åˆæ¨¡å¼ï¼Œç„¶åç»˜åˆ¶
            tempCtx.drawImage(maskCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // è·å–ç»˜åˆ¶åçš„æ•°æ®ï¼Œè½¬æ¢ä¸ºçº¯é»‘ç™½
            const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            for (let i = 0; i < data.data.length; i += 4) {
                // æ£€æŸ¥çº¢è‰²é€šé“ï¼ˆç”»ç¬”æ˜¯çº¢è‰² rgba(255, 0, 0, 0.5)ï¼‰
                // ç»˜åˆ¶åˆ°é»‘è‰²èƒŒæ™¯ä¸Šåï¼Œçº¢è‰²åŒºåŸŸçš„ R å€¼ä¼š > 0
                const r = data.data[i];
                const g = data.data[i + 1];
                const b = data.data[i + 2];
                
                // å¦‚æœæœ‰çº¢è‰²æˆåˆ†ï¼ˆç”»ç¬”æ ‡è®°çš„åŒºåŸŸï¼‰ï¼Œè®¾ç½®ä¸ºç™½è‰²
                if (r > 20 || g > 20 || b > 20) {
                    data.data[i] = 255;     // R
                    data.data[i + 1] = 255; // G
                    data.data[i + 2] = 255; // B
                } else {
                    data.data[i] = 0;       // R
                    data.data[i + 1] = 0;   // G
                    data.data[i + 2] = 0;   // B
                }
                data.data[i + 3] = 255;     // A - å®Œå…¨ä¸é€æ˜
            }
            tempCtx.putImageData(data, 0, 0);
            
            console.log(`[Mask] Generated mask: ${tempCanvas.width}x${tempCanvas.height}`);
            return tempCanvas.toDataURL('image/png');
        }

        // å¤„ç†å›¾ç‰‡
        processBtn.addEventListener('click', async () => {
            if (!currentFile) {
                showError('è¯·å…ˆä¸Šä¼ å›¾ç‰‡ï¼');
                return;
            }

            // æ‰‹åŠ¨æ¨¡å¼æ£€æŸ¥æ˜¯å¦æœ‰æ ‡è®°
            if (currentMode === 'manual') {
                const maskDataURL = getMaskDataURL();
                if (!maskDataURL) {
                    showError('è¯·å…ˆç”¨ç”»ç¬”æ ‡è®°éœ€è¦å»é™¤çš„æ°´å°åŒºåŸŸï¼');
                    return;
                }
            }

            loading.style.display = 'block';
            loading.querySelector('div:last-child').textContent = 'æ­£åœ¨ä½¿ç”¨ AI å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...';
            processBtn.disabled = true;
            errorMsg.style.display = 'none';
            
            // æ˜¾ç¤ºé¢„è§ˆå®¹å™¨
            previewContainer.style.display = 'grid';
            
            // éšè—ç¼–è¾‘å™¨å’Œæ£€æµ‹æç¤º
            detectionResult.style.display = 'none';

            const formData = new FormData();
            formData.append('file', currentFile);
            formData.append('mode', currentMode);
            
            // å¦‚æœæ˜¯æ‰‹åŠ¨æ¨¡å¼ï¼Œæ·»åŠ  mask æ•°æ®
            if (currentMode === 'manual') {
                const maskDataURL = getMaskDataURL();
                if (maskDataURL) {
                    formData.append('mask', maskDataURL);
                }
            }
            
            // å¦‚æœæ˜¯è‡ªåŠ¨æ¨¡å¼ä¸”ç”¨æˆ·è°ƒæ•´äº†åŒºåŸŸï¼Œå‘é€è‡ªå®šä¹‰åæ ‡
            if (currentMode === 'auto' && customWatermarkRegion) {
                formData.append('custom_region', JSON.stringify(customWatermarkRegion));
                console.log('[Process] Using custom region:', customWatermarkRegion);
            }

            // ä¸­æ­¢ä¹‹å‰çš„è¯·æ±‚
            abortCurrentRequest();
            currentAbortController = new AbortController();

            try {
                const response = await fetch('/api/remove-watermark', {
                    method: 'POST',
                    body: formData,
                    signal: currentAbortController.signal
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'å¤„ç†å¤±è´¥');
                }

                processedImageBlob = await response.blob();
                const imageUrl = URL.createObjectURL(processedImageBlob);
                processedImage.src = imageUrl;
                downloadBtn.style.display = 'inline-block';
                showSuccess('æ°´å°å»é™¤æˆåŠŸï¼');
                
                // éšè—ç¼–è¾‘å™¨ï¼Œåªæ˜¾ç¤ºç»“æœå¯¹æ¯”
                editorContainer.classList.remove('visible');
                removeWatermarkOverlay();
                currentAbortController = null;

            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('[Process] Request was aborted');
                    return;
                }
                showError('å¤„ç†å¤±è´¥ï¼š' + error.message);
            } finally {
                loading.style.display = 'none';
                processBtn.disabled = false;
                currentAbortController = null;
            }
        });

        // ä¸‹è½½å›¾ç‰‡
        downloadBtn.addEventListener('click', () => {
            if (processedImageBlob) {
                const url = URL.createObjectURL(processedImageBlob);
                const a = document.createElement('a');
                a.href = url;
                const filename = currentFile.name || 'image.png';
                a.download = 'processed_' + filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });

        // é‡ç½®
        resetBtn.addEventListener('click', () => {
            // ä¸­æ­¢æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚
            abortCurrentRequest();
            
            // éšè—åŠ è½½çŠ¶æ€
            loading.style.display = 'none';
            
            currentFile = null;
            processedImageBlob = null;
            imageObj = null;
            detectedWatermark = null;
            fileInput.value = '';
            originalImage.src = '';
            processedImage.src = '';
            previewContainer.style.display = 'none';
            downloadBtn.style.display = 'none';
            processBtn.disabled = true;
            errorMsg.style.display = 'none';
            successMsg.style.display = 'none';
            uploadArea.style.display = 'block';
            editorContainer.classList.remove('visible');
            detectionResult.style.display = 'none';
            
            // ç§»é™¤æ°´å°æ ‡è®°
            removeWatermarkOverlay();
            
            // æ¸…ç©ºç”»å¸ƒ
            if (imgCtx) {
                imgCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            }
            if (maskCtx) {
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            }
        });
    </script>
</body>
</html>
